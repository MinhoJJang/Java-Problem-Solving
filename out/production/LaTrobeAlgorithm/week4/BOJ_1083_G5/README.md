        /**
         * swap 가능한 위치
         *
         * S = 1,000,000
         *
         * BubbleSort 느낌
         *
         * 일단, 가장 사전순으로 뒤에 있는 단어를 만들고
         * 그 단어가 되기 위해??
         * 
         * local 최대 = global max 
         * 
         * 이 되려면 결국 greedy라는 건데
         * 
         * 문제는 이런 경우다
         * 
         * 3 5 6 1 4
         * 5 3 6 1 4
         * 5 6 3 1 4 
         * 
         * S = 2라면 
         * 이렇게 순서대로? swap을 하면 global 최대에 도달할 수 없다. 
         * 
         * global max은 
         * 
         * 3 6 5 1 4
         * 6 3 5 1 4 
         * 
         */

그럼 케이스를 나눠보자

1 3 2 8

greedy로 순서대로 swap 시 5회\
3 1 2 8\
3 2 1 8\
3 2 8 1\
3 8 2 1\
8 3 2 1

최적 3회\
3 1 8 2\
3 8 1 2\
8 3 1 2

---
가장 사전순으로 뒤에 있는 숫자(A)가 앞에 오는 순간 

A a1 a2 a3 ...

이제 남은 S로 
a1 a2 a3을 소트하는 것과 똑같다. 

그럼 내가 할일은
a1 a2 a3 ..  중 가장 큰 숫자 위치를 찾고
그 위치와 맨 처음 위치와의 거리 n을 계산해본다. -> 이를 fn() 이라고하자

만약 S가 n보다 커
그럼 일단 그 큰 수를 맨앞으로 땡기고
나머지를 밀어 
이렇게하려면 LinkedList로 구현해야겠네

그럼 S-n 만큼이 남아
그럼 맨앞은 고정이고
나머지를 다시 fn에 넣어

반복

그러다가 이제 언제끝나냐

S보다 n이 작으면

예를들어서 

1 5 3 2 8
인데 

S가 3이야 
3이면 8을 맨앞으로 못땡기네?

그럼 8 다음으로 큰 값을 찾아
5네?

5 1 3 2 8
하고 
S = 2로 만들어줘

1 3 2 8 이 있는데
8 땡길수있음?
못땡김
그럼 그담큰수 3을 땡겨

S = 1이야
3 1 2 8이 됐어

---
그럼만약에 

1 2 3 8 이면?
S = 2이고 

그럼 3 1 2 8이 되는게 맞지
맞네그럼
---

3고정이니
1 2 8 근데 S = 1이야 
그럼 8 못땡기고 그담 큰수 2를 땡겨

그럼 2 1 8이네?

ㅇㅋ

알았다

1 3 2 8 10
---
1 3 2 8

10 
---















